#include "ThrGenerator.h"
#include <cmath>
#include <sstream>
#include <algorithm>
#include <iomanip>

const double PI = 3.14159265358979323846;

std::vector<ThrPoint> ThrGenerator::generate_thr(const std::vector<Point>& points, int width, int height) {
    if (points.empty()) return {};

    double center_x = width / 2.0;
    double center_y = height / 2.0;

    // Use fixed max radius based on table size (inscribed circle)
    // This ensures perimeter paths at the edge stay at rho=1.0
    double max_radius = std::min(width, height) / 2.0;
    if (max_radius == 0) max_radius = 1.0;

    std::vector<ThrPoint> polar_points;
    double prev_theta = 0.0;
    bool first = true;

    for (const auto& p : points) {
        double dx = p.x - center_x;
        double dy = p.y - center_y;

        double rho = std::sqrt(dx * dx + dy * dy) / max_radius;
        rho = std::min(1.0, std::max(0.0, rho));

        // Note: -dy because y-axis is inverted in images (top-left is 0,0)
        double theta = std::atan2(-dy, dx);

        if (!first) {
            while (theta - prev_theta > PI) theta -= 2 * PI;
            while (theta - prev_theta < -PI) theta += 2 * PI;
        } else {
            first = false;
        }

        polar_points.push_back({theta, rho});
        prev_theta = theta;
    }

    // Add boundary points
    if (!polar_points.empty()) {
        std::vector<ThrPoint> result;
        result.push_back({polar_points.front().theta, 0.0});
        result.insert(result.end(), polar_points.begin(), polar_points.end());
        result.push_back({polar_points.back().theta, 0.0});
        return result;
    }

    return polar_points;
}

std::string ThrGenerator::to_string(const std::vector<ThrPoint>& thr_points) {
    std::stringstream ss;
    ss << "# Generated by ThrGen C++\n";
    ss << "# Sisyphus kinetic sand table format\n\n";
    ss << std::fixed << std::setprecision(5);
    for (const auto& p : thr_points) {
        ss << p.theta << " " << p.rho << "\n";
    }
    return ss.str();
}
