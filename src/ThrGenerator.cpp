#include "ThrGenerator.h"
#include <cmath>
#include <sstream>
#include <algorithm>
#include <iomanip>

const double PI = 3.14159265358979323846;

std::vector<ThrPoint> ThrGenerator::generate_thr(const std::vector<Point>& points, int width, int height) {
    if (points.empty()) return {};

    double center_x = width / 2.0;
    double center_y = height / 2.0;

    // Use fixed max radius based on table size (inscribed circle)
    // This ensures perimeter paths at the edge stay at rho=1.0
    double max_radius = std::min(width, height) / 2.0;
    if (max_radius == 0) max_radius = 1.0;

    std::vector<ThrPoint> polar_points;
    double prev_theta = 0.0;
    bool first = true;

    for (const auto& p : points) {
        double dx = p.x - center_x;
        double dy = p.y - center_y;

        double rho = std::sqrt(dx * dx + dy * dy) / max_radius;
        rho = std::min(1.0, std::max(0.0, rho));

        // Standard polar: match SisyphusTable convention
        // Image Y increases downward, which matches canvas Y in the viewer
        double theta = std::atan2(dy, dx);

        if (!first) {
            while (theta - prev_theta > PI) theta -= 2 * PI;
            while (theta - prev_theta < -PI) theta += 2 * PI;
        } else {
            first = false;
        }

        polar_points.push_back({theta, rho});
        prev_theta = theta;
    }

    // Add boundary points
    if (!polar_points.empty()) {
        std::vector<ThrPoint> result;
        result.push_back({polar_points.front().theta, 0.0});
        result.insert(result.end(), polar_points.begin(), polar_points.end());
        result.push_back({polar_points.back().theta, 0.0});
        return result;
    }

    return polar_points;
}

std::string ThrGenerator::to_string(const std::vector<ThrPoint>& thr_points) {
    std::stringstream ss;
    ss << "# Generated by ThrGen C++\n";
    ss << "# Sisyphus kinetic sand table format\n\n";
    ss << std::fixed << std::setprecision(5);
    for (const auto& p : thr_points) {
        ss << p.theta << " " << p.rho << "\n";
    }
    return ss.str();
}

std::vector<ThrPoint> ThrGenerator::parse(const std::string& thr_content) {
    std::vector<ThrPoint> points;
    std::istringstream stream(thr_content);
    std::string line;

    while (std::getline(stream, line)) {
        // Skip empty lines and comments
        if (line.empty() || line[0] == '#') continue;

        std::istringstream line_stream(line);
        double theta, rho;
        if (line_stream >> theta >> rho) {
            points.push_back({theta, rho});
        }
    }

    return points;
}

std::vector<Point> ThrGenerator::to_cartesian(const std::vector<ThrPoint>& thr_points, int width, int height) {
    std::vector<Point> points;
    if (thr_points.empty()) return points;

    double center_x = width / 2.0;
    double center_y = height / 2.0;
    double max_radius = std::min(width, height) / 2.0;

    for (const auto& tp : thr_points) {
        int x = static_cast<int>(center_x + std::cos(tp.theta) * tp.rho * max_radius);
        int y = static_cast<int>(center_y + std::sin(tp.theta) * tp.rho * max_radius);
        points.push_back({x, y});
    }

    return points;
}
